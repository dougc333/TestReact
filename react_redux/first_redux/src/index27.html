//using react-redux
//https://github.com/udacity/reactnd-redux-todos-goals/commit/e6ab31c60bcac704f05b21627594328e56478efd

<!DOCTYPE html>
<html>
<head>
  <title>Udacity Todos Goals</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js"></script>
  <script src="https://unpkg.com/react@16.3.0-alpha.1/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@16.3.0-alpha.1/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
  <script src='https://tylermcginnis.com/goals-todos-api/index.js'></script>
  <script src="https://unpkg.com/redux-thunk@2.2.0/dist/redux-thunk.min.js"></script>
  <script src="https://unpkg.com/react-redux@5.0.6/dist/react-redux.min.js"></script>
</head>
<body>

<hr />
<div id='app'>
</div>

  <script type='text/javascript'>

   function generateId () {
      return Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);
    }

    //replace library code with redux

    // App Code
    const ADD_TODO = 'ADD_TODO'
    const REMOVE_TODO = 'REMOVE_TODO'
    const TOGGLE_TODO = 'TOGGLE_TODO'
    const ADD_GOAL = 'ADD_GOAL'
    const REMOVE_GOAL = 'REMOVE_GOAL'
    const RECEIVE_DATA='RECEIVE_DATA'
    

    function receiveDataAction(todos,goals){
      return{
        type:RECEIVE_DATA,
        todos,
        goals
      }
    }

    function addTodoAction (todo) {
      return {
        type: ADD_TODO,
        todo,
      }
    }
    function removeTodoAction (id) {
      return {
        type: REMOVE_TODO,
        id,
      }
    }
    function toggleTodoAction (id) {
      return {
        type: TOGGLE_TODO,
        id,
      }
    }
    function addGoalAction (goal) {
      return {
        type: ADD_GOAL,
        goal,
      }
    }
    function removeGoalAction (id) {
      return {
        type: REMOVE_GOAL,
        id,
      }
    }
    //instead of returning an object return a function. Good technique. 
    function handleDeleteTodo(todo){
      return (dispatch)=>{
        dispatch(removeTodoAction(todo.id))

        return API.deleteTodo(todo.id).catch(()=>{
          dispatch(addTodoAction(todo))
          alert('error removeItem adding back')
      })
      }
    }

    function handleAddTodo(name,cb){
      return (dispatch)=>{
        return API.saveTodo(name)
          .then((todo)=>{
            dispatch(addTodoAction(todo))
            cb()
          }).catch(()=>
            alert('error todo addItem')
          )
      }
    }

    function handleToggle(id){
      return (dispatch)=>{
        dispatch(toggleTodoAction(id))
        
        return API.saveTodoToggle(id).catch(()=>{
          dispatch(toggleTodoAction(id))
          alert('toggleItem addign back')
        })
      }
    }

    function handleAddGoal(name,cb){
        return (dispatch)=>{
          return API.saveGoal(name)
          .then((goal)=>{
            dispatch(addGoalAction(goal))
            cb()
          })
          .catch(()=>
            alert("goal addItem error")
          )
        }
    }

    function handleDeleteGoal(goal){
      return (dispatch) => {
        dispatch(removeGoalAction(goal.id))

        return API.deleteGoal(goal.id)
        .catch( ()=>{
          dispatch(addGoalAction(goal))
          alert('an error goadd added back')
        })
      }
    }

    function handleInitialData(){
      return(dispatch)=>{
        return Promise.all([
        API.fetchTodos(),
        API.fetchGoals()])
        .then(([todos,goals])=>{
          //console.log('todos:',todos)
          //console.log('goals:',goals)
          dispatch(receiveDataAction(todos,goals))
        })
      }
    }

    //end action creators

    function todos (state = [], action) {
      switch(action.type) {
        case ADD_TODO :
          return state.concat([action.todo])
        case REMOVE_TODO :
          return state.filter((todo) => todo.id !== action.id)
        case TOGGLE_TODO :
          return state.map((todo) => todo.id !== action.id ? todo :
            Object.assign({}, todo, { complete: !todo.complete }))
        case RECEIVE_DATA:
          return action.todos
        default :
          return state
      }
    }
    function goals (state = [], action) {
      switch(action.type) {
        case ADD_TODO:
          console.log("ADD_TODO")
        case TOGGLE_TODO:
          return state.map((todo)=>todo.id !== action.id ?todo:
          Object.assign({},todo,{complete: !todo.complete }))
        case RECEIVE_DATA:
          return action.goals
        case ADD_GOAL :
          return state.concat([action.goal])
        case REMOVE_GOAL :
          return state.filter((goal) => goal.id !== action.id)
        default :
          return state
      }
    }

    function loading(state=true, action){
      switch(action.type){
        case RECEIVE_DATA:
          return false
        default:
          return true
      }
    }


      //next is next middleware or dispatch, this nested function syntax is currying pattern
      function checker(store){
      return function(next){
        return function(action){
          //have access to store,next and action
          if(
            action.type===ADD_TODO &&
            action.todo.name.toLowerCase().includes('bitcoin')
          )
          {
            return alert('bad idea')
          }
          if(
            action.type===ADD_GOAL && action.goal.name.toLowerCase().includes('bitcoin')        
          ){
            return alert('still bad idea')
          }
            return next(action)
          }
      }
    }

    const logger = (store)=>(next) =>(action)=>{
      console.group(action.type)
        console.log('the action:',action)
        const result = next(action)
        console.log('new state:',store.getState())
      console.groupEnd()
      return result
    }

    // const thunk = (store)=>(next)=>(action)=>{
    //   if (typeof(action) === 'function'){
    //     return action(store.dispatch)
    //   }
    //   return next(action)
    // }
//  line below was: Redux.applyMiddleware(thunk,checker,logger)

    const store = Redux.createStore(Redux.combineReducers({
      todos,
      goals,
      loading,
    }),Redux.applyMiddleware(ReduxThunk.default,checker,logger))

  </script>

  <script type="text/babel">

    function List(props){
      return(
        <ul>
          <li>List</li>
          {props.items.map((item)=>(
            <li key={item.id}>
            <span
              onClick = {()=>props.toggle && props.toggle(item.id)}
              style={{textDecoration : item.complete ? 'line-through' : 'none'}}>
              {item.name}
            </span>
            <button onClick={()=>props.remove(item)}>
            X </button>
            </li>
          ))}
        </ul>
      )
    }

    function connect (mapStateToProps){
      return (Component=>{
        class Receiver extends React.Component{
          componentDidMount(){
            const {subscribe} = this.props.store
            this.unsubscribe = subscribe(()=>{
              this.forceUpdate()
            })
          }
          componentWillUnmount(){
            this.unsubscribe()
          }
          render(){
            const {dispatch,getState} = this.props.store
            const state = getState()
            const stateNeeded = mapStateToProps(state)

            return()
          }
        }
      })


    }


    //no optimistic updates w/addItem becsause you need todo 
    //object back from API
    class Todos extends React.Component{
      addItem=(e)=>{
        e.preventDefault()
        this.props.dispatch(handleAddTodo(
            this.input.value,
            ()=>this.input.value = ''
        ))
      }

      removeItem = (todo)=>{
        this.props.dispatch(handleDeleteTodo(todo))
      }

      toggleItem = (id) =>{
        this.props.dispatch(handleToggle(id))
      }

      render(){
        return(
          <div> 
          <h6 >todo</h6>
            <input 
            type="text"
            placeholder="add todo..."
            ref={(input) => this.input=input} 
            /> 
            <button onClick={this.addItem}>
            add todo button  
            </button>
            <List 
            items={this.props.todos}
            remove = {this.removeItem}
            toggle = {this.toggleItem} 
            />
          </div>
        )
      }
    }



    class Goals extends React.Component{
      addItem =(e) =>{
        e.preventDefault()
        this.prop.dispatch(handleAddGoal(
            this.input.value,
            ()=>this.input.value=''
        ))
      }

      removeItem = (goal)=>{
        this.props.dispatch(handleDeleteGoal(goal))
      }

      render(){
        return(
          <div>
            <h6>Goals</h6>
            <input
            type="text"
            placeholder="add goals"
            ref = {(input)=>this.input = input}
            />
            <button onClick={this.addItem}>
            add goal
            </button>
            <List
              items = {this.props.goals}
              remove = {this.removeItem}
            />
          </div>

        )
      }
    }
    
    const ConnectedGoals = ReactRedux.connect((state)=>({
        goals:state.goals
    }))(Goals)

    const ConnectedTodos = ReactRedux.connect((state)=>({
        todos:state.todos
    }))(Todos)

    //connect() returns the function then the second () runs it
    //first set paren pass in data component needs, 
    //second set paren pass in component going to be rendered
    //the parameters loading automatically get passsed to App!
    const ConnectedApp = ReactRedux.connect((state)=>({
        loading:state.loading
    }))(App)


    class App extends React.Component{
      componentDidMount(){
        const { dispatch } = this.props
        dispatch(handleInitialData())
      }

      //we can remove this.. like the other way wo this div
      //if (this.props.loading===true){
      //    return (<h3>loading</h3>)
      //}

      render(){        
        return(
          <div>
            <ConnectedTodos />
            <ConnectedGoals />
          </div>
        )
      }
    }
    ReactDOM.render(
    <ReactRedux.Provider store={store} >
      <ConnectedApp />
    </ReactRedux.Provider>,
      document.getElementById('app')
    )
  </script>
</body>
</html> 
