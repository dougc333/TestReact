//connected components part1
//this is screwed up, not correct. video doesnt match
//
<!DOCTYPE html>
<html>
<head>
  <title>Udacity Todos Goals</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js"></script>
  <script src="https://unpkg.com/react@16.3.0-alpha.1/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@16.3.0-alpha.1/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
  <script src='https://tylermcginnis.com/goals-todos-api/index.js'></script>
  <script src="https://unpkg.com/redux-thunk@2.2.0/dist/redux-thunk.min.js"></script>
</head>
<body>

<hr />
<div id='App'>
</div>

  <script type='text/javascript'>

   function generateId () {
      return Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);
    }

    //replace library code with redux

    // App Code
    const ADD_TODO = 'ADD_TODO'
    const REMOVE_TODO = 'REMOVE_TODO'
    const TOGGLE_TODO = 'TOGGLE_TODO'
    const ADD_GOAL = 'ADD_GOAL'
    const REMOVE_GOAL = 'REMOVE_GOAL'
    const RECEIVE_DATA='RECEIVE_DATA'
    

    function receiveDataAction(todos,goals){
      return{
        type:RECEIVE_DATA,
        todos,
        goals
      }
    }

    function addTodoAction (todo) {
      return {
        type: ADD_TODO,
        todo,
      }
    }
    function removeTodoAction (id) {
      return {
        type: REMOVE_TODO,
        id,
      }
    }
    function toggleTodoAction (id) {
      return {
        type: TOGGLE_TODO,
        id,
      }
    }
    function addGoalAction (goal) {
      return {
        type: ADD_GOAL,
        goal,
      }
    }
    function removeGoalAction (id) {
      return {
        type: REMOVE_GOAL,
        id,
      }
    }
    //instead of returning an object return a function. Good technique. 
    function handleDeleteTodo(todo){
      return (dispatch)=>{
        dispatch(removeTodoAction(todo.id))

        return API.deleteTodo(todo.id).catch(()=>{
          dispatch(addTodoAction(todo))
          alert('error removeItem adding back')
      })
      }
    }

    function handleAddTodo(name,cb){
      return (dispatch)=>{
        return API.saveTodo(name)
          .then((todo)=>{
            dispatch(addTodoAction(todo))
            cb()
          }).catch(()=>
            alert('error todo addItem')
          )
      }
    }

    function handleToggle(id){
      return (dispatch)=>{
        dispatch(toggleTodoAction(id))
        
        return API.saveTodoToggle(id).catch(()=>{
          dispatch(toggleTodoAction(id))
          alert('toggleItem addign back')
        })
      }
    }

    function handleAddGoal(name,cb){
        return (dispatch)=>{
          return API.saveGoal(name)
          .then((goal)=>{
            dispatch(addGoalAction(goal))
            cb()
          })
          .catch(()=>
            alert("goal addItem error")
          )
        }
    }

    function handleDeleteGoal(goal){
      return (dispatch) => {
        dispatch(removeGoalAction(goal.id))

        return API.deleteGoal(goal.id)
        .catch( ()=>{
          dispatch(addGoalAction(goal))
          alert('an error goadd added back')
        })
      }
    }

    function handleInitialData(){
      return(dispatch)=>{
        return Promise.all([
        API.fetchTodos(),
        API.fetchGoals()])
        .then(([todos,goals])=>{
          //console.log('todos:',todos)
          //console.log('goals:',goals)
          dispatch(receiveDataAction(todos,goals))
        })
      }
    }

    //end action creators

    function todos (state = [], action) {
      switch(action.type) {
        case ADD_TODO :
          return state.concat([action.todo])
        case REMOVE_TODO :
          return state.filter((todo) => todo.id !== action.id)
        case TOGGLE_TODO :
          return state.map((todo) => todo.id !== action.id ? todo :
            Object.assign({}, todo, { complete: !todo.complete }))
        case RECEIVE_DATA:
          return action.todos
        default :
          return state
      }
    }
    function goals (state = [], action) {
      switch(action.type) {
        case ADD_TODO:
          console.log("ADD_TODO")
        case TOGGLE_TODO:
          return state.map((todo)=>todo.id !== action.id ?todo:
          Object.assign({},todo,{complete: !todo.complete }))
        case RECEIVE_DATA:
          return action.goals
        case ADD_GOAL :
          return state.concat([action.goal])
        case REMOVE_GOAL :
          return state.filter((goal) => goal.id !== action.id)
        default :
          return state
      }
    }

    function loading(state=true, action){
      switch(action.type){
        case RECEIVE_DATA:
          return false
        default:
          return true
      }
    }


      //next is next middleware or dispatch, this nested function syntax is currying pattern
      function checker(store){
      return function(next){
        return function(action){
          //have access to store,next and action
          if(
            action.type===ADD_TODO &&
            action.todo.name.toLowerCase().includes('bitcoin')
          )
          {
            return alert('bad idea')
          }
          if(
            action.type===ADD_GOAL && action.goal.name.toLowerCase().includes('bitcoin')        
          ){
            return alert('still bad idea')
          }
            return next(action)
          }
      }
    }

    const logger = (store)=>(next) =>(action)=>{
      console.group(action.type)
        console.log('the action:',action)
        const result = next(action)
        console.log('new state:',store.getState())
      console.groupEnd()
      return result
    }

    // const thunk = (store)=>(next)=>(action)=>{
    //   if (typeof(action) === 'function'){
    //     return action(store.dispatch)
    //   }
    //   return next(action)
    // }
//  line below was: Redux.applyMiddleware(thunk,checker,logger)

    const store = Redux.createStore(Redux.combineReducers({
      todos,
      goals,
      loading,
    }),Redux.applyMiddleware(ReduxThunk.default,checker,logger))

  </script>

  <script type="text/babel">

    function List(props){
      return(
        <ul>
          <li>List</li>
          {props.items.map((item)=>(
            <li key={item.id}>
            <span
              onClick = {()=>props.toggle && props.toggle(item.id)}
              style={{textDecoration : item.complete ? 'line-through' : 'none'}}>
              {item.name}
            </span>
            <button onClick={()=>props.remove(item)}>
            X </button>
            </li>
          ))}
        </ul>
      )
    }

    // class ConnectedGoals extends React.Component{
    //   render(){
    //     return(
    //       <Context.Consumer>
    //         {(store)=>{
    //           const {goals} = store.getState()
    //           return(<Goals goals={goals} dispatch={store.dispatch}/>)
    //         }}
    //       </Context.Consumer>
    //     )
    //   }
    // }

    //this is a techique connect()(). the first parenthesis is a function and 
    //the vars we get from that are passed as parameters to the component in the second parenthesis
    //
    const ConnectedGoals = connect((state)=>{
      goals: state.goals
    })(Goals)

    // class ConnectedTodos extends React.Component{
    //   render(){
    //     return(
    //       <Context.Consumer>
    //         {(store)=>{
    //           const {todos} =store.getState()
    //           return(
    //             <Todos todos={todos} dispatch={store.dispatch} />
    //           )
    //         }}
    //       </Context.Consumer>
    //     )
    //   }
    // }

    const ConnectedTodos = connect((state)=>{
      todos:state.todos
    })(Todos)

    //no optimistic updates w/addItem becsause you need todo 
    //object back from API
    class Todos extends React.Component{
      addItem=(e)=>{
        e.preventDefault()
        this.props.dispatch(handleAddTodo(
            this.input.value,
            ()=>this.input.value = ''
        ))
      }

      removeItem = (todo)=>{
        this.props.dispatch(handleDeleteTodo(todo))
      }

      toggleItem = (id) =>{
        this.props.dispatch(handleToggle(id))
      }

      render(){
        return(
          <div> 
          <h6 >todo</h6>
            <input 
            type="text"
            placeholder="add todo..."
            ref={(input) => this.input=input} 
            /> 
            <button onClick={this.addItem}>
            add todo button  
            </button>
            <List 
            items={this.props.todos}
            remove = {this.removeItem}
            toggle = {this.toggleItem} 
            />
          </div>
        )
      }
    }

    class Goals extends React.Component{
      addItem =(e) =>{
        e.preventDefault()
        this.props.dispatch(handleAddGoal(
            this.input.value,
            ()=>this.input.value=''
        ))
      }

      removeItem = (goal)=>{
        this.props.dispatch(handleDeleteGoal(goal))
      }

      render(){
        return(
          <div>
            <h6>Goals</h6>
            <input
            type="text"
            placeholder="add goals"
            ref = {(input)=>this.input = input}
            />
            <button onClick={this.addItem}>
            add goal
            </button>
            <List
              items = {this.props.goals}
              remove = {this.removeItem}
            />
          </div>

        )
      }
    }

    

    class App extends React.Component{
      componentDidMount(){
        //const {store} = this.props
        const {dispatch} = this.props
        dispatch(handleInitialData())
      }

      render(){
        //const {store} = this.props
        //const {loading} = store.getState()
        if(this.props.loading===true){
          return <h3>loading</h3>
        }

        return(
          <div>
            <ConnectedTodos />
            <ConnectedGoals />
          </div>
        )
      }
    }

    // class ConnectedApp extends React.Component{
    //   render(){
    //     return(
    //       <Context.Consumer>
    //         {(state)=>(
    //           <App store={state} />
    //         )}
    //       </Context.Consumer>
    //     )
    //   }
    // }
    const ConnectedApp = connect((state)=>({
      //any properties from the ()=>will be passe to App
      loading:state.loading
    }))(App)

    const Context = React.createContext()

    function connect(mapStateToProps){
      //first thing we need is to return a function which is passed to the
      //component App when called above
      return (Component)=>{
        class Receiver extends React.Component{
          componentDidMount(){
            const {subscribe} = this.props.store
            this.unsubscribe = subscribe(()=>{
              this.forceUpdate();
            })
          }
          componentWillUnmount(){
            this.unsubscribe();
          }
          render(){
            const {dispatch, getState} = this.props.store
            const state = getState();
            const stateNeeded = mapStateToProps(state)

            return < Component {...stateNeeded} dispatch={dispatch} />
          }
        }

        class ConnectedComponent extends React.Component{
          render(){
            return(
              <Context.Consumer>
                {(store)=><Receiver store={store} />}
              </Context.Consumer>
            )
          }
        }
        return ConnectedComponent
      }
    }

    class Provider extends React.Component{
      render(){
        return(
          <Context.Provider value = {this.props.store} >
            {this.props.children}
          </Context.Provider>
        )
      }
    }

    ReactDOM.render(
      <Provider store={store} >
      <ConnectedApp />
      </Provider>,
      document.getElementById('App')
    )
  </script>
</body>
</html> 



